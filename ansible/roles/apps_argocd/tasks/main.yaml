- name: Retrieve application informations
  vars:
    manifest: "{{ lookup('file', manifests_folder + '/argocd.yaml') | from_yaml }}"
    values: "{{ manifest.spec.source.plugin.env.1.value | replace('$$', '$') | from_yaml }}"
    host: "https://{{ manifest.metadata.annotations['sebtiz13.fr/host'] }}"
  ansible.builtin.set_fact:
    apps_argocd:
      _manifest: "{{ manifest }}"
      _values: "{{ values }}"
      release_name: "{{ manifest.spec.source.plugin.env.0.value }}"
      namespace: "{{ manifest.spec.destination.namespace }}"
      host: "{{ host }}"
    argocd_api_url: "{{ host }}/api/v1"

- name: Create application namespace
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig.dest }}"
    state: present
    resource_definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: "{{ apps_argocd.namespace }}"
        labels:
          domain: "{{ root_domain }}"

- name: Add chart repo
  kubernetes.core.helm_repository:
    name: argo-cd
    repo_url: "{{ apps_argocd._manifest.spec.source.repoURL }}"

- name: Retrieve appVersion
  vars:
    chart: "argo-cd/{{ apps_argocd._manifest.spec.source.chart }}"
    version: "{{ apps_argocd._manifest.spec.source.targetRevision }}"
  ansible.builtin.shell: |
    set -o pipefail
    helm repo update argo-cd > /dev/null
    helm search repo '{{ chart }}' --version '{{ version }}' -o json | jq -r '.[0].app_version'
  changed_when: false
  register: argocd_app_version

- name: Download CRDs
  vars:
    base_url: "https://raw.githubusercontent.com/argoproj/argo-cd/{{ argocd_app_version.stdout }}/manifests/crds"
  ansible.builtin.uri:
    url: "{{ base_url }}/{{ item }}-crd.yaml"
    method: GET
    return_content: true
    status_code: 200
  register: argocd_crds
  loop:
    - application
    - applicationset
    - appproject
- name: Deploy patched CRDs
  vars:
    metadata_patch:
      metadata:
        labels:
          app.kubernetes.io/managed-by: Helm
        annotations:
          meta.helm.sh/release-namespace: "{{ apps_argocd.namespace }}"
          meta.helm.sh/release-name: "{{ apps_argocd.release_name }}"
    manifest: "{{ item.content | from_yaml | combine(metadata_patch, recursive=True) }}"
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig.dest }}"
    state: present
    resource_definition: "{{ manifest }}"
  loop: "{{ argocd_crds.results }}"
  loop_control:
    label: "{{ item.item }}"

- name: Check if ArgoCD is already deploy
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig.dest }}"
    kind: Service
    name: "{{ apps_argocd.release_name }}-server"
    namespace: "{{ apps_argocd.namespace }}"
  register: argocd_server

- name: Deploy extra objects
  when: argocd_server.resources | length == 0 # This prevent re deploy with helm when is already deployed
  vars:
    metadata_patch:
      metadata:
        labels:
          app.kubernetes.io/managed-by: Helm
        annotations:
          meta.helm.sh/release-namespace: "{{ apps_argocd.namespace }}"
          meta.helm.sh/release-name: "{{ apps_argocd.release_name }}"
    manifest: "{{ item | from_yaml | combine(metadata_patch, recursive=True) }}"
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig.dest }}"
    state: present
    namespace: "{{ apps_argocd.namespace }}"
    resource_definition: "{{ manifest }}"
    validate:
      fail_on_error: true
  loop: "{{ apps_argocd._values.extraObjects | default([]) }}"
  loop_control:
    label: "{{ item.metadata.name }}"

- name: Deploy chart
  when: argocd_server.resources | length == 0 # This prevent re deploy with helm when is already deployed
  kubernetes.core.helm:
    kubeconfig: "{{ kubeconfig.dest }}"
    chart_ref: "argo-cd/{{ apps_argocd._manifest.spec.source.chart }}"
    chart_version: "{{ apps_argocd._manifest.spec.source.targetRevision }}"
    release_name: "{{ apps_argocd.release_name }}"
    release_namespace: "{{ apps_argocd.namespace }}"
    release_values: "{{ apps_argocd._values }}"
    wait: true
  register: argocd_deploy

##
# Create admin token and update admin password
##
- name: Retrieve server service
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig.dest }}"
    kind: Service
    name: "{{ apps_argocd.release_name }}-server"
    namespace: "{{ apps_argocd.namespace }}"
  register: argocd_server
- name: Retrieve initial admin password # noqa: no-handler
  when: argocd_deploy is changed
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig.dest }}"
    kind: Secret
    name: "{{ apps_argocd.release_name }}-initial-admin-secret"
    namespace: "{{ apps_argocd.namespace }}"
  register: argocd_initial_admin_password

- name: Create auth token
  connection: ssh
  vars:
    initial_password: "{{ argocd_initial_admin_password.resources.0.data.password | b64decode }}"
  ansible.builtin.uri:
    url: "http://{{ argocd_server.resources.0.spec.clusterIP }}/api/v1/session"
    method: POST
    return_content: true
    status_code: 200
    body_format: json
    body:
      username: admin
      password: "{{ initial_password | default(admin_passwords.argocd) }}"
  register: argocd_admin_auth

- name: Update admin password
  when:
    - argocd_initial_admin_password is not skipped
    - argocd_initial_admin_password.resources | length > 0
  connection: ssh
  ansible.builtin.uri:
    url: "http://{{ argocd_server.resources.0.spec.clusterIP }}/api/v1/account/password"
    method: PUT
    headers:
      Authorization: "Bearer {{ argocd_admin_auth.json.token }}"
    return_content: true
    status_code: 200
    body_format: json
    body:
      name: admin
      currentPassword: "{{ argocd_initial_admin_password.resources.0.data.password | b64decode }}"
      newPassword: "{{ admin_passwords.argocd }}"
  register: argocd_admin_update_password
  changed_when: argocd_admin_update_password.status == 200
  notify:
    - Delete initial admin password secret
    - Recreate auth token
